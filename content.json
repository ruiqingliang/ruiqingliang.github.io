{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"计算机基础笔记","slug":"软考/1-计算机基础","date":"2021-12-31T09:41:12.000Z","updated":"2022-01-05T06:30:49.673Z","comments":true,"path":"2021/12/31/软考/1-计算机基础/","link":"","permalink":"http://example.com/2021/12/31/%E8%BD%AF%E8%80%83/1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/","excerpt":"","text":"1. 计算机系统基础计算机系统由硬件、软件组成。 计算机硬件基础 运算器、控制器、存储器、输入设备、输出设备5部分组成 运算器、控制器整合在CPU中. 输入输出设备统称为外部设备（外设） 运算器运算器主要负责算术（+-*/)、逻辑运算(与、或、非等)。 ALU（算术逻辑单元） 累加器寄存器，通用寄存器，为ALU提供工作区，存放计算结果，至少有一个累加器寄存器 数据缓冲寄存器，缓冲内存与CPU的数据交换 状态条件寄存器，记录执行运算的状态（溢出、0标示、负标示等） 控制器控制器主要负责对各个元器件调度，commander，主要职责有： 指令控制逻辑 时许控制逻辑 总线控制逻辑 中断控制逻辑指令控制逻辑完成取指、译指、执行操作，主要部件有： IR（指令寄存器），指令从内存加载到缓存寄存器，在加载到IR中，平衡内存访问速度的差异。 PC（程序计数器），存放下一条需要执行的指令地址。 AR（地址寄存器），存放操作读写内存的地址。 译码器，用来解析指令的正确性，分析出操作码、操作数。 数值表示对数字的编码方式有：原码、反码、补码、移码正数的原码、反码、补码均相同。负数的规则如下： 原码：最高位是符号位置（0正，1负）其余位置是数值位。eg： -1=[1 … 0001B], 1=[0 … 0001B] 反码：在原码的基础上，符号位不动，其余位置取反。eg：-1=[1111 … 1110], 1=[0111 … 1110] 补码：在反码的基础上+1，eg：-1=[1111 … 1111], 1=[0111 … 1111] 移码：在补码的基础上，符号位取反 eg: -1=[0111 …. 1111], 1=[1111 … 1111] 对数字的编码实现：浮点数、定点数 定点数：小数点在固定的位置，要么在有效数字位最后面，要么在有效数字位最前面。 浮点数：类似于科学计数法，N = F * 2^E 工业标准组织IEEE，将浮点数表示标准化(IEEE 754), N=(-1)^s * M * 2^E 浮点数表示中，阶码（E）不全为0&amp;不全为1，表示规格化的值。 浮点数表示中，阶码全为0，表示非规格化的值。因为M是一个&gt;= 1的值，所以表示+0的是时候，符号为、阶码、尾数全部用0表示。 浮点数表示中，阶码全为1，表示特殊值。尾数部分全是0，表示无穷大（符号0表示正无穷大，1表示负无穷大）；当尾数不全是0表示NaN，不是一个数。 校验码数据在电路中传输的时候，可能会发生损坏，如某个一个硬件故障，将高电平转换为低电平。如何保证数据的正确性，就需要用到了校验码。主要是实现手段是码距。主要的校验方法有： 奇偶校验 海明校验 循环冗余校验(CRC)多用在数据通讯领域 海明校验：在原始数据的特定位置插入校验码，每个校验码检验多个数据位，解析时通过计算数据位于校验位的奇偶情况进行错误验证，同时支持1位错误的纠正。在2的次幂位置插入验证位。数据位数为r, 校验码位数为k，需要保证 math.pow(2, k) - 1 &gt;= r + k编码：原始数据为 0110 1001 海明码位置 位置类型 海明码位置的二进制 H1 k1 0001 H2 k2 0010 H3 r1 0011 H4 k3 0100 H5 r2 0101 H6 r3 0110 H7 r4 0111 H8 k4 1000 H9 r5 1001 H10 r6 1010 H11 r7 1011 H12 r8 1100 通过上表的按照二进制的位值=1按照纵列分组，可以得到下表： 分组ID 负责校验的位置 G1 H1, H3, H5, H7, H9, H11 G2 H3, H6, H7, H10, H11 G3 H4, H5, H6, H12 G4 H8, H9, H10, H11, H12 其中H1、H2、H4、H8位检验位置如果是偶校验，保证每个分组位置相加%2==0，如此就可以知道H1、H2、H4、H8这些校验位置的取值。将校验码、数据填充在合理位置，即得到了数据的海明码。 计算机体系结构 计算机体系结构，概括性的描述计算机组成部分与功能组织。（个人认为图灵机的表述属于这一范畴） 计算机组织，又称计算机组成原理（描述了各个部件的工作方式） 计算机实现，物理实现。 计算机体系结构的分类按照处理机数量可分类为： 单处理系统 并行处理与多处理系统 分布式处理系统 其他的分类方式还有Flynn、冯泽云、handler、kuck分类。Flynn根据数据流与指令流，分成： 单数据流单指令流 单处理器系统 多数据流单指令流 阵列处理机 单数据流多指令流 理论上 多指令流多数据流 多处理器系统 指令系统","categories":[],"tags":[{"name":"计算机、计算机基础","slug":"计算机、计算机基础","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}]},{"title":"reactor事件模型","slug":"reactor事件模型","date":"2021-11-16T12:58:55.000Z","updated":"2021-11-24T03:09:01.430Z","comments":true,"path":"2021/11/16/reactor事件模型/","link":"","permalink":"http://example.com/2021/11/16/reactor%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"系统APIlisten select selectint select(int nfds, fd_set *restrict readfds, fd_set *restrict writefds, fd_set *restrict errorfds, struct timeval *restrict timeout); bitmap [011010111100111] 下标index代表fd，值1代表关心这个fd POSIX 规定fd必须从小到大使用 epoll \bepoll epoll_create epoll_ctl epoll_wait基于select的网络模型 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;#include &lt;assert.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;sys/select.h&gt;#include &lt;string.h&gt;#include &lt;netinet/in.h&gt;#define MAX_FD 100int fds[MAX_FD]; //存储多个文件描述符的数组int max_fs = -1;void init_fds(int sock)&#123; int i = 0; for(; i&lt;MAX_FD; i++)&#123; fds[i] = -1; &#125; max_fs = sock; fds[0] = sock;&#125;int add_fds(int fd)&#123; int i = 1, j = 0; // 第一个元素是监听socket for(;i&lt;MAX_FD;i++)&#123; if (fds[i] == -1) &#123; fds[i] = fd; j ++; break; &#125; &#125; return j;&#125;int del_fds(int fd)&#123; int i = 1, j = 0; if(fd == -1)&#123; return j; &#125; for(;i&lt;MAX_FD;i++)&#123; if(fds[i] == fd)&#123; fds[i] = -1; j++; break; &#125; &#125; return j;&#125;// 每次select后，都会清空标志位，再次初始化，并更新最大fd的值void set_fs_set(fd_set* _)&#123; int i = 0; max_fs = -1; for(; i&lt;MAX_FD; i++)&#123; if(fds[i] != -1)&#123; FD_SET(fds[i], _); &#125; if(max_fs &lt; fds[i])&#123; max_fs = fds[i]; &#125; &#125;&#125;void print_time(int count, int total_fds, int valid_fds, int max_fs,char* msg)&#123; time_t t; struct tm * lt; time (&amp;t); //获取Unix时间戳。 lt = localtime (&amp;t); //转为时间结构。 printf ( &quot;%d:%d:%d %s = %d, total_fds=%d, valid_fds=%d, max_fs=%d\\n&quot; ,lt-&gt;tm_hour, lt-&gt;tm_min, lt-&gt;tm_sec, msg, count, total_fds, valid_fds, max_fs); //输出结果&#125;int main(void)&#123; // 忽略SIGPIPE信号， 如果不处理这个信号，客户端异常关闭后，socket读取、写入时， // 将引发系统的SIGPIPE信号，导致进程异常退出 // struct sigaction sa; // sa.sa_handler = SIG_IGN; // sigaction( SIGPIPE, &amp;sa, 0 ); int sock = socket(AF_INET, SOCK_STREAM, 0); assert(sock != -1); // 初始化存放fd的数组 init_fds(sock); struct sockaddr_in si, ci; si.sin_family = AF_INET; si.sin_port = htons(atoi(&quot;8005&quot;)); si.sin_addr.s_addr = htonl(INADDR_ANY); int ret = bind(sock, (struct sockaddr *) &amp;si, sizeof(si)); if(ret == -1)&#123; perror(&quot;bind error&quot;); exit(2); &#125; listen(sock, 50); fd_set rset; // 只关心可读事件 for(;;)&#123; FD_ZERO(&amp;rset);// 重置成0 // 设置关心的fd，第一次只有一个监听socket set_fs_set(&amp;rset); struct timeval tv = &#123;3, 0&#125;; // 堵塞，直到有事件返回 int r = select(max_fs+1, &amp;rset, NULL, NULL, &amp;tv); if(r &lt; 0)&#123; perror(&quot;select error\\n&quot;); exit(0); &#125;else if (r == 0)&#123; printf(&quot;select timeout \\n&quot;); &#125;else&#123; int i = 0, total_fd_cnt = 0, valid_fd_cnt = 0; for(; i&lt;MAX_FD; i++)&#123; if(fds[i] == -1)&#123; continue; &#125; total_fd_cnt++; if(FD_ISSET(fds[i], &amp;rset))&#123; valid_fd_cnt ++; // 如果是监听socket，可读事件就是来了新连接了 if(fds[i] == sock)&#123; socklen_t addr_length = sizeof(struct sockaddr_in); int new_cli = accept(sock, (struct sockaddr*)&amp;ci, &amp;addr_length); if(new_cli &lt; 0)&#123; perror(&quot;new connection error \\n&quot;); continue; &#125;else&#123; add_fds(new_cli); printf(&quot;new connection, port=%d \\n&quot;, ntohs(ci.sin_port)); &#125; &#125; else&#123; char buff[10] = &#123;0&#125;; int n = recv(fds[i], buff, sizeof(buff), 0); if(n &lt;= 0)&#123; // 这个地方应该读取错误信息，select有可读事件，但是读不到数据，说明有异常。 // 此时客户端close退出，返回0，异常退出返回-1 if(n != 0) perror(&quot;recv null&quot;); del_fds(fds[i]); if(close(fds[i])!=0)&#123; perror(&quot;recv close error&quot;); &#125; &#125;else&#123; //printf(&quot;old connection, port=%d, data=%s\\n&quot;, ntohs(ci.sin_port), buff); n = send(fds[i], &quot;ok\\r\\n&quot;, 4, 0); //通recv if(n&lt;=0)&#123; if(n != 0) perror(&quot;send null&quot;); del_fds(fds[i]); if(close(fds[i])!=0)&#123; perror(&quot;send close error&quot;); &#125; &#125; &#125; &#125; &#125; &#125; print_time(r, total_fd_cnt, valid_fd_cnt, max_fs+1, &quot;server execute&quot;); &#125; &#125; printf(&quot;program exit \\n&quot;); return 0;&#125; 基于epoll的网络模型123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;stdio.h&gt;#include &lt;sys/socket.h&gt;#include &lt;sys/epoll.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &lt;pthread.h&gt;#include &lt;signal.h&gt;#define PORT 8005#define MAX_CONN 1024static int g_efd;int main(int argc, char const *argv[])&#123; printf(&quot;测试程序开始运行 \\n&quot;); // 忽略SIGPIPE信号， 如果不处理这个信号，客户端异常关闭后，socket读取、写入时， // 将引发系统的SIGPIPE信号，导致进程异常退出 struct sigaction sa; sa.sa_handler = SIG_IGN; sigaction( SIGPIPE, &amp;sa, 0 ); int lfd = socket(AF_INET, SOCK_STREAM, 0); if(lfd == -1)&#123; perror(&quot;创建 listen socket 失败 \\n&quot;); exit(1); &#125;else&#123; printf(&quot;创建监听socket：%d \\n&quot;, lfd); &#125; // 创建epoll对象 g_efd = epoll_create(MAX_CONN+1); if(g_efd &lt;= 0)&#123; printf(&quot;exit, create epoll object fail, in %s, errorno=%s \\n&quot;, __func__, strerror(errno)); exit(1); &#125; struct sockaddr_in laddr, caddr; socklen_t len; laddr.sin_family = AF_INET; laddr.sin_port = htons(PORT); // inet_aton(&quot;127.0.0.1&quot;, laddr.sin_addr); inet_pton(AF_INET, &quot;0.0.0.0&quot;, &amp;laddr.sin_addr); // laddr.sin_addr.s_addr = htonl(INADDR_ANY); int ret = bind(lfd, (struct sockaddr *)&amp;laddr, sizeof(laddr)); if(ret == -1)&#123; printf(&quot;exit, bind port fail, in %s, errorno=%s \\n&quot;, __func__, strerror(errno)); exit(1); &#125;else&#123; printf(&quot;bind成功\\n&quot;); &#125; ret = listen(lfd, 50); if(ret == -1)&#123; printf(&quot;exit, listen fail, in %s, errorno=%s \\n&quot;, __func__, strerror(errno)); exit(1); &#125;else&#123; printf(&quot;启动listen\\n&quot;); &#125; struct epoll_event ev; struct epoll_event events[MAX_CONN]; //事件监听队列 ev.events = EPOLLIN; ev.data.fd = lfd; ret = epoll_ctl(g_efd, EPOLL_CTL_ADD, lfd, &amp;ev); if(ret == -1)&#123; printf(&quot;exit, epoll_ctl fail, in %s, errorno=%s \\n&quot;, __func__, strerror(errno)); exit(1); &#125; while(1)&#123; int nfd = epoll_wait(g_efd, events, MAX_CONN, -1); for(int i = 0; i &lt; nfd; i ++)&#123; if(events[i].data.fd == lfd)&#123; int cfd = accept(lfd, (struct sockaddr *)&amp;caddr, &amp;len); if(cfd == -1)&#123; printf(&quot;exit, accept fail, in %s, errorno=%s \\n&quot;, __func__, strerror(errno)); exit(1); &#125; ev.events = EPOLLIN; ev.data.fd = cfd; ret = epoll_ctl(g_efd, EPOLL_CTL_ADD, cfd, &amp;ev); if(ret == -1)&#123; printf(&quot;exit, accpet epoll_ctl fail, in %s, errorno=%s \\n&quot;, __func__, strerror(errno)); exit(1); &#125; printf(&quot;new connection ... addr:%s, port:%d \\n&quot;, inet_ntoa(caddr.sin_addr), ntohs(caddr.sin_port)); &#125;else&#123; char read_buff[1024*1024]; memset(read_buff, 0, sizeof(read_buff)); ret = recv(events[i].data.fd, read_buff, sizeof(read_buff), 0); if(ret == -1)&#123; perror(&quot;read error \\n&quot;); &#125;else&#123; printf(&quot;client socket: %d, send content is %s \\n&quot;, events[i].data.fd, read_buff); ret = send(events[i].data.fd, read_buff, sizeof(read_buff), 0); if(ret == -1)&#123; perror(&quot;send error \\n&quot;); &#125; &#125; &#125; &#125; &#125; printf(&quot;测试程序运行正常，退出\\n&quot;); return 0;&#125; redis的网络模型12345ae_select.cae_kqueue.cae_epoll.cae.c 对epoll的封装 ae_epoll.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;sys/epoll.h&gt;typedef struct aeApiState &#123; int epfd; struct epoll_event *events;&#125; aeApiState;static int aeApiCreate(aeEventLoop *eventLoop) &#123; aeApiState *state = zmalloc(sizeof(aeApiState)); if (!state) return -1; state-&gt;events = zmalloc(sizeof(struct epoll_event)*eventLoop-&gt;setsize); if (!state-&gt;events) &#123; zfree(state); return -1; &#125; state-&gt;epfd = epoll_create(1024); /* 1024 is just a hint for the kernel */ if (state-&gt;epfd == -1) &#123; zfree(state-&gt;events); zfree(state); return -1; &#125; anetCloexec(state-&gt;epfd); eventLoop-&gt;apidata = state; return 0;&#125;static int aeApiResize(aeEventLoop *eventLoop, int setsize) &#123; aeApiState *state = eventLoop-&gt;apidata; state-&gt;events = zrealloc(state-&gt;events, sizeof(struct epoll_event)*setsize); return 0;&#125;static void aeApiFree(aeEventLoop *eventLoop) &#123; aeApiState *state = eventLoop-&gt;apidata; close(state-&gt;epfd); zfree(state-&gt;events); zfree(state);&#125;static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask) &#123; aeApiState *state = eventLoop-&gt;apidata; struct epoll_event ee = &#123;0&#125;; /* avoid valgrind warning */ /* If the fd was already monitored for some event, we need a MOD * operation. Otherwise we need an ADD operation. */ int op = eventLoop-&gt;events[fd].mask == AE_NONE ? EPOLL_CTL_ADD : EPOLL_CTL_MOD; ee.events = 0; mask |= eventLoop-&gt;events[fd].mask; /* Merge old events */ if (mask &amp; AE_READABLE) ee.events |= EPOLLIN; if (mask &amp; AE_WRITABLE) ee.events |= EPOLLOUT; ee.data.fd = fd; if (epoll_ctl(state-&gt;epfd,op,fd,&amp;ee) == -1) return -1; return 0;&#125;static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int delmask) &#123; aeApiState *state = eventLoop-&gt;apidata; struct epoll_event ee = &#123;0&#125;; /* avoid valgrind warning */ int mask = eventLoop-&gt;events[fd].mask &amp; (~delmask); ee.events = 0; if (mask &amp; AE_READABLE) ee.events |= EPOLLIN; if (mask &amp; AE_WRITABLE) ee.events |= EPOLLOUT; ee.data.fd = fd; if (mask != AE_NONE) &#123; epoll_ctl(state-&gt;epfd,EPOLL_CTL_MOD,fd,&amp;ee); &#125; else &#123; /* Note, Kernel &lt; 2.6.9 requires a non null event pointer even for * EPOLL_CTL_DEL. */ epoll_ctl(state-&gt;epfd,EPOLL_CTL_DEL,fd,&amp;ee); &#125;&#125;static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) &#123; aeApiState *state = eventLoop-&gt;apidata; int retval, numevents = 0; retval = epoll_wait(state-&gt;epfd,state-&gt;events,eventLoop-&gt;setsize, tvp ? (tvp-&gt;tv_sec*1000 + (tvp-&gt;tv_usec + 999)/1000) : -1); if (retval &gt; 0) &#123; int j; numevents = retval; for (j = 0; j &lt; numevents; j++) &#123; int mask = 0; struct epoll_event *e = state-&gt;events+j; if (e-&gt;events &amp; EPOLLIN) mask |= AE_READABLE; if (e-&gt;events &amp; EPOLLOUT) mask |= AE_WRITABLE; if (e-&gt;events &amp; EPOLLERR) mask |= AE_WRITABLE|AE_READABLE; if (e-&gt;events &amp; EPOLLHUP) mask |= AE_WRITABLE|AE_READABLE; eventLoop-&gt;fired[j].fd = e-&gt;data.fd; eventLoop-&gt;fired[j].mask = mask; &#125; &#125; return numevents;&#125;static char *aeApiName(void) &#123; return &quot;epoll&quot;;&#125; 对网络接口的封装 ae.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473#include &quot;ae.h&quot;#include &quot;anet.h&quot;#include &lt;stdio.h&gt;#include &lt;sys/time.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;poll.h&gt;#include &lt;string.h&gt;#include &lt;time.h&gt;#include &lt;errno.h&gt;#include &quot;zmalloc.h&quot;#include &quot;config.h&quot;/* Include the best multiplexing layer supported by this system. * The following should be ordered by performances, descending. */#ifdef HAVE_EVPORT#include &quot;ae_evport.c&quot;#else #ifdef HAVE_EPOLL #include &quot;ae_epoll.c&quot; #else #ifdef HAVE_KQUEUE #include &quot;ae_kqueue.c&quot; #else #include &quot;ae_select.c&quot; #endif #endif#endifaeEventLoop *aeCreateEventLoop(int setsize) &#123; aeEventLoop *eventLoop; int i; monotonicInit(); /* just in case the calling app didn&#x27;t initialize */ if ((eventLoop = zmalloc(sizeof(*eventLoop))) == NULL) goto err; eventLoop-&gt;events = zmalloc(sizeof(aeFileEvent)*setsize); eventLoop-&gt;fired = zmalloc(sizeof(aeFiredEvent)*setsize); if (eventLoop-&gt;events == NULL || eventLoop-&gt;fired == NULL) goto err; eventLoop-&gt;setsize = setsize; eventLoop-&gt;timeEventHead = NULL; eventLoop-&gt;timeEventNextId = 0; eventLoop-&gt;stop = 0; eventLoop-&gt;maxfd = -1; eventLoop-&gt;beforesleep = NULL; eventLoop-&gt;aftersleep = NULL; eventLoop-&gt;flags = 0; if (aeApiCreate(eventLoop) == -1) goto err; /* Events with mask == AE_NONE are not set. So let&#x27;s initialize the * vector with it. */ for (i = 0; i &lt; setsize; i++) eventLoop-&gt;events[i].mask = AE_NONE; return eventLoop;err: if (eventLoop) &#123; zfree(eventLoop-&gt;events); zfree(eventLoop-&gt;fired); zfree(eventLoop); &#125; return NULL;&#125;/* Return the current set size. */int aeGetSetSize(aeEventLoop *eventLoop) &#123; return eventLoop-&gt;setsize;&#125;/* Tells the next iteration/s of the event processing to set timeout of 0. */void aeSetDontWait(aeEventLoop *eventLoop, int noWait) &#123; if (noWait) eventLoop-&gt;flags |= AE_DONT_WAIT; else eventLoop-&gt;flags &amp;= ~AE_DONT_WAIT;&#125;/* Resize the maximum set size of the event loop. * If the requested set size is smaller than the current set size, but * there is already a file descriptor in use that is &gt;= the requested * set size minus one, AE_ERR is returned and the operation is not * performed at all. * * Otherwise AE_OK is returned and the operation is successful. */int aeResizeSetSize(aeEventLoop *eventLoop, int setsize) &#123; int i; if (setsize == eventLoop-&gt;setsize) return AE_OK; if (eventLoop-&gt;maxfd &gt;= setsize) return AE_ERR; if (aeApiResize(eventLoop,setsize) == -1) return AE_ERR; eventLoop-&gt;events = zrealloc(eventLoop-&gt;events,sizeof(aeFileEvent)*setsize); eventLoop-&gt;fired = zrealloc(eventLoop-&gt;fired,sizeof(aeFiredEvent)*setsize); eventLoop-&gt;setsize = setsize; /* Make sure that if we created new slots, they are initialized with * an AE_NONE mask. */ for (i = eventLoop-&gt;maxfd+1; i &lt; setsize; i++) eventLoop-&gt;events[i].mask = AE_NONE; return AE_OK;&#125;void aeDeleteEventLoop(aeEventLoop *eventLoop) &#123; aeApiFree(eventLoop); zfree(eventLoop-&gt;events); zfree(eventLoop-&gt;fired); /* Free the time events list. */ aeTimeEvent *next_te, *te = eventLoop-&gt;timeEventHead; while (te) &#123; next_te = te-&gt;next; zfree(te); te = next_te; &#125; zfree(eventLoop);&#125;void aeStop(aeEventLoop *eventLoop) &#123; eventLoop-&gt;stop = 1;&#125;int aeCreateFileEvent(aeEventLoop *eventLoop, int fd, int mask, aeFileProc *proc, void *clientData)&#123; if (fd &gt;= eventLoop-&gt;setsize) &#123; errno = ERANGE; return AE_ERR; &#125; aeFileEvent *fe = &amp;eventLoop-&gt;events[fd]; if (aeApiAddEvent(eventLoop, fd, mask) == -1) return AE_ERR; fe-&gt;mask |= mask; if (mask &amp; AE_READABLE) fe-&gt;rfileProc = proc; if (mask &amp; AE_WRITABLE) fe-&gt;wfileProc = proc; fe-&gt;clientData = clientData; if (fd &gt; eventLoop-&gt;maxfd) eventLoop-&gt;maxfd = fd; return AE_OK;&#125;void aeDeleteFileEvent(aeEventLoop *eventLoop, int fd, int mask)&#123; if (fd &gt;= eventLoop-&gt;setsize) return; aeFileEvent *fe = &amp;eventLoop-&gt;events[fd]; if (fe-&gt;mask == AE_NONE) return; /* We want to always remove AE_BARRIER if set when AE_WRITABLE * is removed. */ if (mask &amp; AE_WRITABLE) mask |= AE_BARRIER; aeApiDelEvent(eventLoop, fd, mask); fe-&gt;mask = fe-&gt;mask &amp; (~mask); if (fd == eventLoop-&gt;maxfd &amp;&amp; fe-&gt;mask == AE_NONE) &#123; /* Update the max fd */ int j; for (j = eventLoop-&gt;maxfd-1; j &gt;= 0; j--) if (eventLoop-&gt;events[j].mask != AE_NONE) break; eventLoop-&gt;maxfd = j; &#125;&#125;int aeGetFileEvents(aeEventLoop *eventLoop, int fd) &#123; if (fd &gt;= eventLoop-&gt;setsize) return 0; aeFileEvent *fe = &amp;eventLoop-&gt;events[fd]; return fe-&gt;mask;&#125;long long aeCreateTimeEvent(aeEventLoop *eventLoop, long long milliseconds, aeTimeProc *proc, void *clientData, aeEventFinalizerProc *finalizerProc)&#123; long long id = eventLoop-&gt;timeEventNextId++; aeTimeEvent *te; te = zmalloc(sizeof(*te)); if (te == NULL) return AE_ERR; te-&gt;id = id; te-&gt;when = getMonotonicUs() + milliseconds * 1000; te-&gt;timeProc = proc; te-&gt;finalizerProc = finalizerProc; te-&gt;clientData = clientData; te-&gt;prev = NULL; te-&gt;next = eventLoop-&gt;timeEventHead; te-&gt;refcount = 0; if (te-&gt;next) te-&gt;next-&gt;prev = te; eventLoop-&gt;timeEventHead = te; return id;&#125;int aeDeleteTimeEvent(aeEventLoop *eventLoop, long long id)&#123; aeTimeEvent *te = eventLoop-&gt;timeEventHead; while(te) &#123; if (te-&gt;id == id) &#123; te-&gt;id = AE_DELETED_EVENT_ID; return AE_OK; &#125; te = te-&gt;next; &#125; return AE_ERR; /* NO event with the specified ID found */&#125;/* How many microseconds until the first timer should fire. * If there are no timers, -1 is returned. * * Note that&#x27;s O(N) since time events are unsorted. * Possible optimizations (not needed by Redis so far, but...): * 1) Insert the event in order, so that the nearest is just the head. * Much better but still insertion or deletion of timers is O(N). * 2) Use a skiplist to have this operation as O(1) and insertion as O(log(N)). */static int64_t usUntilEarliestTimer(aeEventLoop *eventLoop) &#123; aeTimeEvent *te = eventLoop-&gt;timeEventHead; if (te == NULL) return -1; aeTimeEvent *earliest = NULL; while (te) &#123; if (!earliest || te-&gt;when &lt; earliest-&gt;when) earliest = te; te = te-&gt;next; &#125; monotime now = getMonotonicUs(); return (now &gt;= earliest-&gt;when) ? 0 : earliest-&gt;when - now;&#125;/* Process time events */static int processTimeEvents(aeEventLoop *eventLoop) &#123; int processed = 0; aeTimeEvent *te; long long maxId; te = eventLoop-&gt;timeEventHead; maxId = eventLoop-&gt;timeEventNextId-1; monotime now = getMonotonicUs(); while(te) &#123; long long id; /* Remove events scheduled for deletion. */ if (te-&gt;id == AE_DELETED_EVENT_ID) &#123; aeTimeEvent *next = te-&gt;next; /* If a reference exists for this timer event, * don&#x27;t free it. This is currently incremented * for recursive timerProc calls */ if (te-&gt;refcount) &#123; te = next; continue; &#125; if (te-&gt;prev) te-&gt;prev-&gt;next = te-&gt;next; else eventLoop-&gt;timeEventHead = te-&gt;next; if (te-&gt;next) te-&gt;next-&gt;prev = te-&gt;prev; if (te-&gt;finalizerProc) &#123; te-&gt;finalizerProc(eventLoop, te-&gt;clientData); now = getMonotonicUs(); &#125; zfree(te); te = next; continue; &#125; /* Make sure we don&#x27;t process time events created by time events in * this iteration. Note that this check is currently useless: we always * add new timers on the head, however if we change the implementation * detail, this check may be useful again: we keep it here for future * defense. */ if (te-&gt;id &gt; maxId) &#123; te = te-&gt;next; continue; &#125; if (te-&gt;when &lt;= now) &#123; int retval; id = te-&gt;id; te-&gt;refcount++; retval = te-&gt;timeProc(eventLoop, id, te-&gt;clientData); te-&gt;refcount--; processed++; now = getMonotonicUs(); if (retval != AE_NOMORE) &#123; te-&gt;when = now + retval * 1000; &#125; else &#123; te-&gt;id = AE_DELETED_EVENT_ID; &#125; &#125; te = te-&gt;next; &#125; return processed;&#125;/* Process every pending time event, then every pending file event * (that may be registered by time event callbacks just processed). * Without special flags the function sleeps until some file event * fires, or when the next time event occurs (if any). * * If flags is 0, the function does nothing and returns. * if flags has AE_ALL_EVENTS set, all the kind of events are processed. * if flags has AE_FILE_EVENTS set, file events are processed. * if flags has AE_TIME_EVENTS set, time events are processed. * if flags has AE_DONT_WAIT set the function returns ASAP until all * the events that&#x27;s possible to process without to wait are processed. * if flags has AE_CALL_AFTER_SLEEP set, the aftersleep callback is called. * if flags has AE_CALL_BEFORE_SLEEP set, the beforesleep callback is called. * * The function returns the number of events processed. */int aeProcessEvents(aeEventLoop *eventLoop, int flags)&#123; int processed = 0, numevents; /* Nothing to do? return ASAP */ if (!(flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_FILE_EVENTS)) return 0; /* Note that we want to call select() even if there are no * file events to process as long as we want to process time * events, in order to sleep until the next time event is ready * to fire. */ if (eventLoop-&gt;maxfd != -1 || ((flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_DONT_WAIT))) &#123; int j; struct timeval tv, *tvp; int64_t usUntilTimer = -1; if (flags &amp; AE_TIME_EVENTS &amp;&amp; !(flags &amp; AE_DONT_WAIT)) usUntilTimer = usUntilEarliestTimer(eventLoop); if (usUntilTimer &gt;= 0) &#123; tv.tv_sec = usUntilTimer / 1000000; tv.tv_usec = usUntilTimer % 1000000; tvp = &amp;tv; &#125; else &#123; /* If we have to check for events but need to return * ASAP because of AE_DONT_WAIT we need to set the timeout * to zero */ if (flags &amp; AE_DONT_WAIT) &#123; tv.tv_sec = tv.tv_usec = 0; tvp = &amp;tv; &#125; else &#123; /* Otherwise we can block */ tvp = NULL; /* wait forever */ &#125; &#125; if (eventLoop-&gt;flags &amp; AE_DONT_WAIT) &#123; tv.tv_sec = tv.tv_usec = 0; tvp = &amp;tv; &#125; if (eventLoop-&gt;beforesleep != NULL &amp;&amp; flags &amp; AE_CALL_BEFORE_SLEEP) eventLoop-&gt;beforesleep(eventLoop); /* Call the multiplexing API, will return only on timeout or when * some event fires. */ numevents = aeApiPoll(eventLoop, tvp); /* After sleep callback. */ if (eventLoop-&gt;aftersleep != NULL &amp;&amp; flags &amp; AE_CALL_AFTER_SLEEP) eventLoop-&gt;aftersleep(eventLoop); for (j = 0; j &lt; numevents; j++) &#123; aeFileEvent *fe = &amp;eventLoop-&gt;events[eventLoop-&gt;fired[j].fd]; int mask = eventLoop-&gt;fired[j].mask; int fd = eventLoop-&gt;fired[j].fd; int fired = 0; /* Number of events fired for current fd. */ /* Normally we execute the readable event first, and the writable * event later. This is useful as sometimes we may be able * to serve the reply of a query immediately after processing the * query. * * However if AE_BARRIER is set in the mask, our application is * asking us to do the reverse: never fire the writable event * after the readable. In such a case, we invert the calls. * This is useful when, for instance, we want to do things * in the beforeSleep() hook, like fsyncing a file to disk, * before replying to a client. */ int invert = fe-&gt;mask &amp; AE_BARRIER; /* Note the &quot;fe-&gt;mask &amp; mask &amp; ...&quot; code: maybe an already * processed event removed an element that fired and we still * didn&#x27;t processed, so we check if the event is still valid. * * Fire the readable event if the call sequence is not * inverted. */ if (!invert &amp;&amp; fe-&gt;mask &amp; mask &amp; AE_READABLE) &#123; fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask); fired++; fe = &amp;eventLoop-&gt;events[fd]; /* Refresh in case of resize. */ &#125; /* Fire the writable event. */ if (fe-&gt;mask &amp; mask &amp; AE_WRITABLE) &#123; if (!fired || fe-&gt;wfileProc != fe-&gt;rfileProc) &#123; fe-&gt;wfileProc(eventLoop,fd,fe-&gt;clientData,mask); fired++; &#125; &#125; /* If we have to invert the call, fire the readable event now * after the writable one. */ if (invert) &#123; fe = &amp;eventLoop-&gt;events[fd]; /* Refresh in case of resize. */ if ((fe-&gt;mask &amp; mask &amp; AE_READABLE) &amp;&amp; (!fired || fe-&gt;wfileProc != fe-&gt;rfileProc)) &#123; fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask); fired++; &#125; &#125; processed++; &#125; &#125; /* Check time events */ if (flags &amp; AE_TIME_EVENTS) processed += processTimeEvents(eventLoop); return processed; /* return the number of processed file/time events */&#125;/* Wait for milliseconds until the given file descriptor becomes * writable/readable/exception */int aeWait(int fd, int mask, long long milliseconds) &#123; struct pollfd pfd; int retmask = 0, retval; memset(&amp;pfd, 0, sizeof(pfd)); pfd.fd = fd; if (mask &amp; AE_READABLE) pfd.events |= POLLIN; if (mask &amp; AE_WRITABLE) pfd.events |= POLLOUT; if ((retval = poll(&amp;pfd, 1, milliseconds))== 1) &#123; if (pfd.revents &amp; POLLIN) retmask |= AE_READABLE; if (pfd.revents &amp; POLLOUT) retmask |= AE_WRITABLE; if (pfd.revents &amp; POLLERR) retmask |= AE_WRITABLE; if (pfd.revents &amp; POLLHUP) retmask |= AE_WRITABLE; return retmask; &#125; else &#123; return retval; &#125;&#125;void aeMain(aeEventLoop *eventLoop) &#123; eventLoop-&gt;stop = 0; while (!eventLoop-&gt;stop) &#123; aeProcessEvents(eventLoop, AE_ALL_EVENTS| AE_CALL_BEFORE_SLEEP| AE_CALL_AFTER_SLEEP); &#125;&#125;char *aeGetApiName(void) &#123; return aeApiName();&#125;void aeSetBeforeSleepProc(aeEventLoop *eventLoop, aeBeforeSleepProc *beforesleep) &#123; eventLoop-&gt;beforesleep = beforesleep;&#125;void aeSetAfterSleepProc(aeEventLoop *eventLoop, aeBeforeSleepProc *aftersleep) &#123; eventLoop-&gt;aftersleep = aftersleep;&#125; 参考 linxu man 手册 github redis6.2源码","categories":[],"tags":[{"name":"linux、reactor","slug":"linux、reactor","permalink":"http://example.com/tags/linux%E3%80%81reactor/"}]},{"title":"我的第一个blog","slug":"我的第一个blog","date":"2021-11-15T13:17:12.000Z","updated":"2021-11-16T09:47:55.328Z","comments":true,"path":"2021/11/15/我的第一个blog/","link":"","permalink":"http://example.com/2021/11/15/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAblog/","excerpt":"","text":"fsfsabcfsfs","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2021-11-15T12:52:43.502Z","updated":"2021-11-15T12:52:43.502Z","comments":true,"path":"2021/11/15/hello-world/","link":"","permalink":"http://example.com/2021/11/15/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"计算机、计算机基础","slug":"计算机、计算机基础","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"linux、reactor","slug":"linux、reactor","permalink":"http://example.com/tags/linux%E3%80%81reactor/"}]}