{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"reactor事件模型","slug":"reactor事件模型","date":"2021-11-16T12:58:55.000Z","updated":"2021-11-16T14:10:55.753Z","comments":true,"path":"2021/11/16/reactor事件模型/","link":"","permalink":"http://example.com/2021/11/16/reactor%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"系统APIselect select int select(int nfds, fd_set *restrict readfds, fd_set *restrict writefds, fd_set *restrict errorfds, struct timeval *restrict timeout);bitmap [011010111100111] 下标index代表fd，值1代表关心这个fd POSIX 规定fd必须从小到大使用 epoll \bepoll epoll_create epoll_ctl epoll_wait基于select的网络模型123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;#include &lt;assert.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;sys/select.h&gt;#include &lt;string.h&gt;#include &lt;netinet/in.h&gt;#define MAX_FD 100// /***/// struct MySock &#123;// int id;// int fd;// char sendbuff[BUFFSIZE*BUFFSIZE];// short int state;// char *clientAddr;// &#125;;// int mark_sock(struct MySock*, int state)&#123;// //// &#125;// struct ConnectionQuene// &#123;// struct Connection allUser[BUFFSIZE];// &#125;;int fds[MAX_FD]; //存储多个文件描述符的数组int max_fs = -1;void init_fds(int sock)&#123; int i = 0; for(; i&lt;MAX_FD; i++)&#123; fds[i] = -1; &#125; max_fs = sock; fds[0] = sock;&#125;int add_fds(int fd)&#123; int i = 1, j = 0; // 第一个元素是监听socket for(;i&lt;MAX_FD;i++)&#123; if (fds[i] == -1) &#123; fds[i] = fd; j ++; break; &#125; &#125; return j;&#125;int del_fds(int fd)&#123; int i = 1, j = 0; if(fd == -1)&#123; return j; &#125; for(;i&lt;MAX_FD;i++)&#123; if(fds[i] == fd)&#123; fds[i] = -1; j++; break; &#125; &#125; return j;&#125;// 每次select后，都会清空标志位，再次初始化，并更新最大fd的值void set_fs_set(fd_set* _)&#123; int i = 0; max_fs = -1; for(; i&lt;MAX_FD; i++)&#123; if(fds[i] != -1)&#123; FD_SET(fds[i], _); &#125; if(max_fs &lt; fds[i])&#123; max_fs = fds[i]; &#125; &#125;&#125;void print_time(int count, int total_fds, int valid_fds, int max_fs,char* msg)&#123; time_t t; struct tm * lt; time (&amp;t); //获取Unix时间戳。 lt = localtime (&amp;t); //转为时间结构。 printf ( &quot;%d:%d:%d %s = %d, total_fds=%d, valid_fds=%d, max_fs=%d\\n&quot; ,lt-&gt;tm_hour, lt-&gt;tm_min, lt-&gt;tm_sec, msg, count, total_fds, valid_fds, max_fs); //输出结果&#125;int main(void)&#123; // 忽略SIGPIPE信号， 如果不处理这个信号，客户端异常关闭后，socket读取、写入时， // 将引发系统的SIGPIPE信号，导致进程异常退出 // struct sigaction sa; // sa.sa_handler = SIG_IGN; // sigaction( SIGPIPE, &amp;sa, 0 ); int sock = socket(AF_INET, SOCK_STREAM, 0); assert(sock != -1); // 初始化存放fd的数组 init_fds(sock); struct sockaddr_in si, ci; si.sin_family = AF_INET; si.sin_port = htons(atoi(&quot;8005&quot;)); si.sin_addr.s_addr = htonl(INADDR_ANY); int ret = bind(sock, (struct sockaddr *) &amp;si, sizeof(si)); if(ret == -1)&#123; perror(&quot;bind error&quot;); exit(2); &#125; listen(sock, 50); fd_set rset; // 只关心可读事件 FD_ZERO(&amp;rset);// 重置成0 for(;;)&#123; set_fs_set(&amp;rset); struct timeval tv = &#123;3, 0&#125;; int r = select(max_fs+1, &amp;rset, NULL, NULL, &amp;tv); if(r &lt; 0)&#123; perror(&quot;select error\\n&quot;); exit(0); &#125;else if (r == 0)&#123; printf(&quot;select timeout \\n&quot;); &#125;else&#123; int i = 0, total_fd_cnt = 0, valid_fd_cnt = 0; for(; i&lt;MAX_FD; i++)&#123; if(fds[i] == -1)&#123; continue; &#125; total_fd_cnt++; if(FD_ISSET(fds[i], &amp;rset))&#123; valid_fd_cnt ++; // 如果是监听socket，可读事件就是来了新连接了 if(fds[i] == sock)&#123; socklen_t addr_length = sizeof(struct sockaddr_in); int new_cli = accept(sock, (struct sockaddr*)&amp;ci, &amp;addr_length); if(new_cli &lt; 0)&#123; perror(&quot;new connection error \\n&quot;); continue; &#125;else&#123; add_fds(new_cli); printf(&quot;new connection, port=%d \\n&quot;, ntohs(ci.sin_port)); &#125; &#125; else&#123; char buff[10] = &#123;0&#125;; int n = recv(fds[i], buff, sizeof(buff), 0); if(n &lt;= 0)&#123; // 这个地方应该读取错误信息，select有可读事件，但是读不到数据，说明有异常。 // 此时客户端close退出，返回0，异常退出返回-1 if(n != 0) perror(&quot;recv null&quot;); del_fds(fds[i]); if(close(fds[i])!=0)&#123; perror(&quot;recv close error&quot;); &#125; &#125;else&#123; //printf(&quot;old connection, port=%d, data=%s\\n&quot;, ntohs(ci.sin_port), buff); n = send(fds[i], &quot;ok\\r\\n&quot;, 4, 0); //通recv if(n&lt;=0)&#123; if(n != 0) perror(&quot;send null&quot;); del_fds(fds[i]); if(close(fds[i])!=0)&#123; perror(&quot;send close error&quot;); &#125; &#125; &#125; &#125; &#125; &#125; print_time(r, total_fd_cnt, valid_fd_cnt, max_fs+1, &quot;server execute&quot;); &#125; &#125; printf(&quot;program exit \\n&quot;); return 0;&#125; 基于epoll的网络模型123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;stdio.h&gt;#include &lt;sys/socket.h&gt;#include &lt;sys/epoll.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &lt;pthread.h&gt;#include &lt;signal.h&gt;#define PORT 8005#define MAX_CONN 1024static int g_efd;int main(int argc, char const *argv[])&#123; printf(&quot;测试程序开始运行 \\n&quot;); // 忽略SIGPIPE信号， 如果不处理这个信号，客户端异常关闭后，socket读取、写入时， // 将引发系统的SIGPIPE信号，导致进程异常退出 struct sigaction sa; sa.sa_handler = SIG_IGN; sigaction( SIGPIPE, &amp;sa, 0 ); int lfd = socket(AF_INET, SOCK_STREAM, 0); if(lfd == -1)&#123; perror(&quot;创建 listen socket 失败 \\n&quot;); exit(1); &#125;else&#123; printf(&quot;创建监听socket：%d \\n&quot;, lfd); &#125; // 创建epoll对象 g_efd = epoll_create(MAX_CONN+1); if(g_efd &lt;= 0)&#123; printf(&quot;exit, create epoll object fail, in %s, errorno=%s \\n&quot;, __func__, strerror(errno)); exit(1); &#125; struct sockaddr_in laddr, caddr; socklen_t len; laddr.sin_family = AF_INET; laddr.sin_port = htons(PORT); // inet_aton(&quot;127.0.0.1&quot;, laddr.sin_addr); inet_pton(AF_INET, &quot;0.0.0.0&quot;, &amp;laddr.sin_addr); // laddr.sin_addr.s_addr = htonl(INADDR_ANY); int ret = bind(lfd, (struct sockaddr *)&amp;laddr, sizeof(laddr)); if(ret == -1)&#123; printf(&quot;exit, bind port fail, in %s, errorno=%s \\n&quot;, __func__, strerror(errno)); exit(1); &#125;else&#123; printf(&quot;bind成功\\n&quot;); &#125; ret = listen(lfd, 50); if(ret == -1)&#123; printf(&quot;exit, listen fail, in %s, errorno=%s \\n&quot;, __func__, strerror(errno)); exit(1); &#125;else&#123; printf(&quot;启动listen\\n&quot;); &#125; struct epoll_event ev; struct epoll_event events[MAX_CONN]; //事件监听队列 ev.events = EPOLLIN; ev.data.fd = lfd; ret = epoll_ctl(g_efd, EPOLL_CTL_ADD, lfd, &amp;ev); if(ret == -1)&#123; printf(&quot;exit, epoll_ctl fail, in %s, errorno=%s \\n&quot;, __func__, strerror(errno)); exit(1); &#125; while(1)&#123; int nfd = epoll_wait(g_efd, events, MAX_CONN, -1); for(int i = 0; i &lt; nfd; i ++)&#123; if(events[i].data.fd == lfd)&#123; int cfd = accept(lfd, (struct sockaddr *)&amp;caddr, &amp;len); if(cfd == -1)&#123; printf(&quot;exit, accept fail, in %s, errorno=%s \\n&quot;, __func__, strerror(errno)); exit(1); &#125; ev.events = EPOLLIN; ev.data.fd = cfd; ret = epoll_ctl(g_efd, EPOLL_CTL_ADD, cfd, &amp;ev); if(ret == -1)&#123; printf(&quot;exit, accpet epoll_ctl fail, in %s, errorno=%s \\n&quot;, __func__, strerror(errno)); exit(1); &#125; printf(&quot;new connection ... addr:%s, port:%d \\n&quot;, inet_ntoa(caddr.sin_addr), ntohs(caddr.sin_port)); &#125;else&#123; char read_buff[1024*1024]; memset(read_buff, 0, sizeof(read_buff)); ret = recv(events[i].data.fd, read_buff, sizeof(read_buff), 0); if(ret == -1)&#123; perror(&quot;read error \\n&quot;); &#125;else&#123; printf(&quot;client socket: %d, send content is %s \\n&quot;, events[i].data.fd, read_buff); ret = send(events[i].data.fd, read_buff, sizeof(read_buff), 0); if(ret == -1)&#123; perror(&quot;send error \\n&quot;); &#125; &#125; &#125; &#125; &#125; printf(&quot;测试程序运行正常，退出\\n&quot;); return 0;&#125; redis的网络模型","categories":[],"tags":[{"name":"linux、reactor","slug":"linux、reactor","permalink":"http://example.com/tags/linux%E3%80%81reactor/"}]},{"title":"我的第一个blog","slug":"我的第一个blog","date":"2021-11-15T13:17:12.000Z","updated":"2021-11-16T09:47:55.328Z","comments":true,"path":"2021/11/15/我的第一个blog/","link":"","permalink":"http://example.com/2021/11/15/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAblog/","excerpt":"","text":"fsfsabcfsfs","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2021-11-15T12:52:43.502Z","updated":"2021-11-15T12:52:43.502Z","comments":true,"path":"2021/11/15/hello-world/","link":"","permalink":"http://example.com/2021/11/15/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"linux、reactor","slug":"linux、reactor","permalink":"http://example.com/tags/linux%E3%80%81reactor/"}]}